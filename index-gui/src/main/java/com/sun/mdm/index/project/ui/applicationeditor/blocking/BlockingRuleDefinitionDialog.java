/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *
 * Copyright 2003-2007 Sun Microsystems, Inc. All Rights Reserved.
 *
 * The contents of this file are subject to the terms of the Common 
 * Development and Distribution License ("CDDL")(the "License"). You 
 * may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the License at
 * https://open-dm-mi.dev.java.net/cddl.html
 * or open-dm-mi/bootstrap/legal/license.txt. See the License for the 
 * specific language governing permissions and limitations under the  
 * License.  
 *
 * When distributing the Covered Code, include this CDDL Header Notice 
 * in each file and include the License file at
 * open-dm-mi/bootstrap/legal/license.txt.
 * If applicable, add the following below this CDDL Header, with the 
 * fields enclosed by brackets [] replaced by your own identifying 
 * information: "Portions Copyrighted [year] [name of copyright owner]"
 */
package com.sun.mdm.index.project.ui.applicationeditor.blocking;

import java.util.ArrayList;
import javax.swing.JTable;
import javax.swing.table.TableColumn;
import javax.swing.table.AbstractTableModel;
import javax.swing.tree.TreeNode;
import javax.swing.table.TableCellEditor;
import javax.swing.DefaultCellEditor;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.JComboBox;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.TreePath;

import org.openide.util.NbBundle;
import org.openide.NotifyDescriptor;
import org.openide.DialogDisplayer;

import com.sun.mdm.index.project.ui.applicationeditor.EntityNode;
import com.sun.mdm.index.project.ui.applicationeditor.EntityTree;

import com.sun.mdm.index.parser.QueryType.BlockDefinition;
import com.sun.mdm.index.parser.QueryType.BlockRule;
import com.sun.mdm.index.parser.QueryType.BlockBy;


/*
<block-definition number="ID3">  --QueryType.BlockDefinition
    <block-rule>                 --QueryType.BlockRule
	<equals>                 --QueryType.BlockBy
            <field>Enterprise.SystemSBR.A.Address.AddressLine1_HouseNo</field>
            <source>A.Address.AddressLine1_HouseNo</source>
	</equals>
	<equals>
            <field>Enterprise.SystemSBR.A.Address.AddressLine1_StPhon</field>
            <source>A.Address.AddressLine1_StPhon</source>
	</equals>
    </block-rule>
</block-definition>
 */
public class BlockingRuleDefinitionDialog extends javax.swing.JDialog implements TreeSelectionListener {
    private ArrayList mAlBlockBys = new ArrayList();
    private EntityTree mEntityTree;
    private JTable mTblBlockRules;
    private boolean mModified = false;
    DefaultCellEditor mOperatorEditor;        
        
    /** Creates new form BlockingRuleDefinitionDialog */
    public BlockingRuleDefinitionDialog(EntityTree entityTree, String queryBuilderName, BlockDefinition blockDefinition, boolean editMode) {
        super(org.openide.windows.WindowManager.getDefault().getMainWindow(), true);
        mEntityTree = entityTree;
        mEntityTree.setEditable(false);
        initComponents();
        // populate data
        jTextFieldQueryBuilderName.setText(queryBuilderName);
        jTextFieldQueryBuilderName.setEnabled(false);

        if (editMode) {
            jTextFieldBlockingRuleName.setText(blockDefinition.getName());
            if (blockDefinition.getHint() != null) {
                jTextFieldHint.setText(blockDefinition.getHint());
            }
            //jTextFieldBlockingRuleName.setEnabled(false);
        } else {
            mEntityTree.expandPath(new TreePath(mEntityTree.getRootNode()));
        }
        mEntityTree.clearSelection();
        loadBlockRulesTable(blockDefinition);            
        mEntityTree.addTreeSelectionListener(this);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {

        btnOK = new javax.swing.JButton();
        btnOK.setEnabled(false);
        btnCancel = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        lblBlockBy = new javax.swing.JLabel();
        jScrollPaneBlockRules = new javax.swing.JScrollPane();
        btnAddBlockRule = new javax.swing.JButton();
        btnRemoveBlockRule = new javax.swing.JButton();
        btnRemoveBlockRule.setEnabled(false);
        jLabelBlockingRuleName = new javax.swing.JLabel();
        jTextFieldBlockingRuleName = new javax.swing.JTextField();
        btnEditBlockRule = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabelHint = new javax.swing.JLabel();
        jTextFieldHint = new javax.swing.JTextField();
        jTextFieldQueryBuilderName = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("com/sun/mdm/index/project/ui/applicationeditor/blocking/Bundle"); // NOI18N
        setTitle(bundle.getString("Title_Block_Definition")); // NOI18N
        setModal(true);

        btnOK.setLabel("OK");
        btnOK.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                onOK(evt);
            }
        });

        btnCancel.setLabel("Cancel");
        btnCancel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                onCancel(evt);
            }
        });

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        lblBlockBy.setText(bundle.getString("LBL_Block_By")); // NOI18N

        btnAddBlockRule.setText(bundle.getString("LBL_Add")); // NOI18N
        btnAddBlockRule.setActionCommand("Add/Remove...");
        btnAddBlockRule.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAddBlockByActionPerformed(evt);
            }
        });

        btnRemoveBlockRule.setText(bundle.getString("LBL_Remove")); // NOI18N
        btnRemoveBlockRule.setEnabled(false);
        btnRemoveBlockRule.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnRemoveBlockByActionPerformed(evt);
            }
        });

        jLabelBlockingRuleName.setText(bundle.getString("LBL_Blocking_Rule_Name")); // NOI18N

        jTextFieldBlockingRuleName.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                onBlockingRuleNameKeyReleased(evt);
            }
        });

        btnEditBlockRule.setText(bundle.getString("LBL_Edit")); // NOI18N
        btnEditBlockRule.setEnabled(false);
        btnEditBlockRule.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnEditBlockByActionPerformed(evt);
            }
        });

        jLabel1.setText(bundle.getString("LBL_Query_Builder")); // NOI18N

        java.util.ResourceBundle bundle1 = java.util.ResourceBundle.getBundle("com/sun/mdm/index/project/ui/applicationeditor/Bundle"); // NOI18N
        jLabelHint.setText(bundle1.getString("LBL_Hint")); // NOI18N

        jTextFieldHint.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                onHintKeyReleased(evt);
            }
        });

        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel1Layout.createSequentialGroup()
                .add(8, 8, 8)
                .add(jLabel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 90, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(jTextFieldQueryBuilderName, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 360, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .add(jPanel1Layout.createSequentialGroup()
                .add(8, 8, 8)
                .add(jLabelBlockingRuleName, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 90, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(jTextFieldBlockingRuleName, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 360, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .add(jPanel1Layout.createSequentialGroup()
                .add(8, 8, 8)
                .add(jLabelHint, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 90, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(jTextFieldHint, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 360, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .add(jPanel1Layout.createSequentialGroup()
                .add(8, 8, 8)
                .add(lblBlockBy, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 90, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .add(jPanel1Layout.createSequentialGroup()
                .add(8, 8, 8)
                .add(jScrollPaneBlockRules, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 580, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .add(jPanel1Layout.createSequentialGroup()
                .add(348, 348, 348)
                .add(btnAddBlockRule, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 80, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(btnRemoveBlockRule, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 80, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(btnEditBlockRule, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 80, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel1Layout.createSequentialGroup()
                .add(8, 8, 8)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jLabel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 20, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jTextFieldQueryBuilderName, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .add(10, 10, 10)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jLabelBlockingRuleName, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 20, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jTextFieldBlockingRuleName, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .add(10, 10, 10)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jLabelHint, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 20, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jTextFieldHint, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .add(10, 10, 10)
                .add(lblBlockBy, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 20, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(jScrollPaneBlockRules, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 220, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(10, 10, 10)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(btnAddBlockRule)
                    .add(btnRemoveBlockRule)
                    .add(btnEditBlockRule)))
        );

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(10, 10, 10)
                .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 600, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
            .add(layout.createSequentialGroup()
                .add(470, 470, 470)
                .add(btnOK, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 70, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(btnCancel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 71, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .add(5, 5, 5)
                .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 380, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(5, 5, 5)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(btnOK)
                    .add(btnCancel)))
        );

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-624)/2, (screenSize.height-449)/2, 624, 449);
    }// </editor-fold>//GEN-END:initComponents

    private void onHintKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_onHintKeyReleased
        enableOK();
    }//GEN-LAST:event_onHintKeyReleased

    private void btnEditBlockByActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnEditBlockByActionPerformed
        int iEditRow = mTblBlockRules.getSelectedRow();
        BlockRulesTableModel model = (BlockRulesTableModel) mTblBlockRules.getModel();
        BlockRulesRow row = model.getRow(iEditRow);
        String field = (String) model.getValueAt(iEditRow, model.iColField);
        String operator = (String) model.getValueAt(iEditRow, model.iColOperator);
        String source = (String) model.getValueAt(iEditRow, model.iColSource);
        boolean useConstant = ((Boolean) model.getValueAt(iEditRow, model.iColUseConstant)).booleanValue();
        BlockByEditDialog dlg = new BlockByEditDialog(mEntityTree, row.getBlockBy());
        dlg.setVisible(true);
        if (dlg.isModified()) {
            //BlockBy blockBy = new BlockBy(dlg.getField(), dlg.getOperator(), dlg.getSource(), dlg.getUseConstant(),
            //                                      dlg.getLowerBoundType(), dlg.getLowerBoundValue(),
            //                                      dlg.getUpperBoundType(), dlg.getUpperBoundValue());
            row.setBlockBy(dlg.getBlockBy());
            model.setValueAt(dlg.getField(), iEditRow, model.iColField);
            model.setValueAt(dlg.getOperator(), iEditRow, model.iColOperator);
            model.setValueAt(dlg.getSource(), iEditRow, model.iColSource);    
            model.setValueAt(Boolean.valueOf(dlg.getUseConstant()), iEditRow, model.iColUseConstant);    
            mAlBlockBys.remove(field);
            mAlBlockBys.add(iEditRow, dlg.getField());
            enableOK();
        }
    }//GEN-LAST:event_btnEditBlockByActionPerformed

    private void onBlockingRuleNameKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_onBlockingRuleNameKeyReleased
        enableOK();
    }//GEN-LAST:event_onBlockingRuleNameKeyReleased

    private void btnAddBlockByActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAddBlockByActionPerformed
        BlockByEditDialog dlg = new BlockByEditDialog(mEntityTree, null);
        dlg.setVisible(true);

        if (dlg.isModified()) {
            BlockRulesTableModel model = (BlockRulesTableModel) mTblBlockRules.getModel();            
            BlockRulesRow row = new BlockRulesRow(dlg.getBlockBy());
            int iInsertTo = this.mTblBlockRules.getRowCount();            
            model.addRow(row, iInsertTo);
            mTblBlockRules.clearSelection();
            mTblBlockRules.addRowSelectionInterval(iInsertTo, iInsertTo);            
            mTblBlockRules.setEditingRow(iInsertTo);
            mAlBlockBys.add(iInsertTo, row.getField());
            btnEditBlockRule.setEnabled(true);        
            btnRemoveBlockRule.setEnabled(true);                    
            enableOK();
        }
    }//GEN-LAST:event_btnAddBlockByActionPerformed

    private void btnRemoveBlockByActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnRemoveBlockByActionPerformed
        int rs[] = mTblBlockRules.getSelectedRows();
        int length = rs.length;
        String prompt = (length == 1) ? NbBundle.getMessage(BlockingRuleDefinitionDialog.class, "MSG_Confirm_Remove_Row_Prompt")
                                        : NbBundle.getMessage(BlockingRuleDefinitionDialog.class, "MSG_Confirm_Remove_Rows_Prompt");

        NotifyDescriptor d = new NotifyDescriptor.Confirmation(
                                 prompt, 
                                 NbBundle.getMessage(BlockingRuleDefinitionDialog.class, "MSG_Confirm_Remove_Row_Title"), 
                                 NotifyDescriptor.YES_NO_OPTION);
        if (DialogDisplayer.getDefault().notify(d) == NotifyDescriptor.YES_OPTION) {
            BlockRulesTableModel model = (BlockRulesTableModel) mTblBlockRules.getModel();
            for (int i=length - 1; i>=0 && i < length; i--) {
                int j = rs[i];
                String targetFieldName = (String) model.getValueAt(j,  1);
                mAlBlockBys.remove(targetFieldName);
                model.removeRow(j);
            }
            btnRemoveBlockRule.setEnabled(false);
            btnEditBlockRule.setEnabled(false);                    
        }
        enableOK();
    }//GEN-LAST:event_btnRemoveBlockByActionPerformed

    private void moveSelectedTargetMappingRow(boolean moveUp) {
        int iSelectedRow = this.mTblBlockRules.getSelectedRow();
        int iInsertTo = iSelectedRow + (moveUp ? -1 : 1);
        BlockRulesTableModel model = (BlockRulesTableModel) mTblBlockRules.getModel();
        BlockRulesRow row = model.removeRow(iSelectedRow);
        mAlBlockBys.remove(iSelectedRow);
        model.addRow(row, iInsertTo);
        mAlBlockBys.add(iInsertTo, row.getField());
        mTblBlockRules.addRowSelectionInterval(iInsertTo, iInsertTo);
        btnRemoveBlockRule.setEnabled(true);
    }
    
    private void onCancel(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_onCancel
        mModified = false;
        this.dispose();
    }//GEN-LAST:event_onCancel

    private void onOK(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_onOK
        mModified = true;
        this.dispose();
    }//GEN-LAST:event_onOK
    
    public String getQueryBuilderName() {
        return this.jTextFieldQueryBuilderName.getText();
    }
    
    public String getBlockDefinitionName() {
        return this.jTextFieldBlockingRuleName.getText();
    }
    
    public String getHint() {
        return this.jTextFieldHint.getText();
    }
    
    public BlockRule getBlockRule() {
        BlockRule blockRule = new BlockRule();    
        blockRule.setBlockBys(getBlockBys());
        return blockRule;
    }
    
    public ArrayList getBlockBys() {
        ArrayList alBlockBys = new ArrayList();
        BlockRulesTableModel blockRulesTableModel = (BlockRulesTableModel) mTblBlockRules.getModel();
        for (int i=0; i < blockRulesTableModel.getRowCount(); i++) {
            BlockRulesRow row = blockRulesTableModel.getRow(i);
            alBlockBys.add(row.getBlockBy());
        }
        return alBlockBys;
    }
    
    public boolean isModified() {
        return mModified;
    }
    
    private void enableOK() {
        btnOK.setEnabled(jTextFieldBlockingRuleName.getText() != null && !jTextFieldBlockingRuleName.getText().equals("") && mTblBlockRules.getRowCount() > 0);
    }
    
    private void loadBlockRulesTable(BlockDefinition blockDefinition) {
        ArrayList rows = new ArrayList();
        if (blockDefinition != null) {
            BlockRule blockRule = blockDefinition.getBlockRule(); // there is only one element now
            ArrayList alBlockBys = blockRule.getBlockBys();

            for (int i=0; i < alBlockBys.size(); i++) {
                BlockBy blockBy = (BlockBy) alBlockBys.get(i);
                BlockRulesRow row = new BlockRulesRow(blockBy);
                rows.add(row);
                mAlBlockBys.add(i, row.getField());
            }
        }
        
        final JComboBox operatorComboBox = new JComboBox();
        operatorComboBox.addItem("equals");
        operatorComboBox.addItem("range");
        
        mOperatorEditor = 
            new DefaultCellEditor(operatorComboBox) {
                public Object getCellEditorValue() {
                    return operatorComboBox.getSelectedItem().toString();
                }
           };
        
        BlockRulesTableModel blockRulesTableModel = new BlockRulesTableModel(rows);
        mTblBlockRules = new JTable(blockRulesTableModel) {
                            public TableCellEditor getCellEditor(int row, int column) {
                                switch (column) {
                                    case 1:
                                        return mOperatorEditor;
                                    default:
                                        break;
                                }
                                return null;                                
                            }};
        mTblBlockRules.getTableHeader().setReorderingAllowed(false);
            
        mOperatorEditor.addCellEditorListener(new CellEditorListener() {
            public void editingStopped(ChangeEvent e) {
                String value = (String) mOperatorEditor.getCellEditorValue();
                mTblBlockRules.setValueAt(value, mTblBlockRules.getSelectedRow(), 1);
                mTblBlockRules.clearSelection();
                btnRemoveBlockRule.setEnabled(false);
                enableOK();
            }

            public void editingCanceled(ChangeEvent e) {
            }        	
        });
        
        jScrollPaneBlockRules.setViewportView(mTblBlockRules);
        int width = jScrollPaneBlockRules.getWidth();
        int i = (width / 5) * 2;
        // Disable auto resizing
        mTblBlockRules.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        // Set width for the "Field" column
        TableColumn col = mTblBlockRules.getColumnModel().getColumn(blockRulesTableModel.iColField);
        col.setPreferredWidth(((width / 5) * 3) - 60);
        // Set width for the "Operator" column
        col = mTblBlockRules.getColumnModel().getColumn(blockRulesTableModel.iColOperator);
        col.setPreferredWidth(65);
        // Set width for the "Source" column
        col = mTblBlockRules.getColumnModel().getColumn(blockRulesTableModel.iColSource);
        col.setPreferredWidth((width / 5) * 2);
        
        mTblBlockRules.addMouseListener(new java.awt.event.MouseAdapter() {
                public void mouseClicked(java.awt.event.MouseEvent evt) {
                    if (evt.getClickCount() == 2) {
                        btnEditBlockByActionPerformed(null);
                    } else {
                        int[] rows = mTblBlockRules.getSelectedRows();                    
                        boolean bEnableEdit = mTblBlockRules.getRowCount() > 0 && 
                                           rows != null &&
                                           rows.length == 1;
                        btnEditBlockRule.setEnabled(bEnableEdit);
                        btnRemoveBlockRule.setEnabled(true);                    
                    }
                }
            });
            
        //btnOK.setEnabled(jTextFieldBlockingRuleName.getText().length() > 0 && mAlBlockBys.size() > 0);
    }
    
    // Table model for BlockRule Types
    class BlockRulesTableModel extends AbstractTableModel {
        private	String columnNames [] = {NbBundle.getMessage(BlockingRuleDefinitionDialog.class, "LBL_BlockRule_Field"),
                                         NbBundle.getMessage(BlockingRuleDefinitionDialog.class, "LBL_BlockRule_Operator"),
                                         NbBundle.getMessage(BlockingRuleDefinitionDialog.class, "LBL_BlockRule_Source")
                                        };
        ArrayList blockRulesRows;
        final int iColField = 0;
        final int iColOperator = 1;        
        final int iColSource = 2;
        final int iColUseConstant = 3;
        
        BlockRulesTableModel(ArrayList rows) {
            blockRulesRows = rows;
        }
        
        public int getColumnCount() {
            return columnNames.length;
        }

        public int getRowCount() {
            if (blockRulesRows != null) {
                return blockRulesRows.size();
            }
            return 0;
        }

        public String getColumnName(int col) {
            return columnNames[col];
        }

        public Object getValueAt(int row, int col) {
            if (blockRulesRows != null && row >= 0 && col >=0) {
                BlockRulesRow singleRow = (BlockRulesRow) blockRulesRows.get(row);
                if (singleRow != null) {
                    switch (col) {
                        case iColField:
                            return singleRow.getField();                    
                        case iColOperator:
                            return singleRow.getOperator();
                        case iColSource:
                            return singleRow.getSource();
                        case iColUseConstant:
                            return Boolean.valueOf(singleRow.getUseConstant());
                        default:
                            break;
                    }
                }
            }
            return null;
        }

        public Class getColumnClass(int c) {
            return getValueAt(0, c).getClass();
        }

        /*
         * Don't need to implement this method unless your table's
         * editable.
         */
        public boolean isCellEditable(int row, int col) {
            //Note that the data/cell address is constant,
            //no matter where the cell appears onscreen.
            if (col == this.iColOperator) {
                //return true;
            }
            return false;
        }

        /*
         * Don't need to implement this method unless your table's
         * data can change.
         */
        public void setValueAt(Object value, int row, int col) {
            if (blockRulesRows != null && row >= 0 && col >= 0) {
                BlockRulesRow singleRow = (BlockRulesRow) blockRulesRows.get(row);
                if (singleRow != null) {
                    switch (col) {
                        case iColField:
                            singleRow.setField((String) value);
                            break;
                        case iColOperator:
                            singleRow.setOperator((String) value);                            
                            break;
                        case iColSource:
                            singleRow.setSource((String) value);                            
                            break;
                        case iColUseConstant:
                            singleRow.setUseConstant(((Boolean) value).booleanValue());                            
                            break;
                    }
                }
            }
            fireTableCellUpdated(row, col);
        }
        
        public BlockRulesRow removeRow(int index) {
            BlockRulesRow singleRow = (BlockRulesRow) blockRulesRows.get(index);
            blockRulesRows.remove(index);
            // update priorities
            this.fireTableRowsDeleted(index, index);
            return singleRow;
        }
        
        public void addRow(BlockRulesRow singleRow, int index) {
            blockRulesRows.add(index, singleRow);
            // update priorities
            this.fireTableRowsInserted(index, index);
        }
        
        public BlockRulesRow getRow(int index) {
            return (BlockRulesRow) blockRulesRows.get(index);
        }
    }
    
    class BlockRulesRow {
        private String field = "";  // Enterprise.SystemSBR.Person.FirstName_Phon
        private String operator = "equals";
        private String source = ""; // Person.FirstName_Phon
        private boolean useConstant = false;
        private String lowerBoundType;  // constant, offset, (null for not defined)
        private String lowerBoundValue; // date, int
        private String upperBoundType;  // constant, offset, (null for not defined)
        private String upperBoundValue; // date, int

        BlockBy blockBy;

        BlockRulesRow(String source) {
            this.field = "Enterprise.SystemSBR." + source;
            this.source = source;            
        }
        
    	BlockRulesRow(String field, String operator, String source, boolean useConstant,
                String lowerBoundType, String lowerBoundValue,
                String upperBoundType, String upperBoundValue) {
            this.field = field;
            this.operator = operator;
            this.source = source;
            this.useConstant = useConstant;
            this.lowerBoundType = lowerBoundType;
            this.lowerBoundValue = lowerBoundValue;
            this.upperBoundType = upperBoundType;
            this.upperBoundValue = upperBoundValue;
            blockBy = new BlockBy(field, operator, source, useConstant,
                                  lowerBoundType, lowerBoundValue,
                                  upperBoundType, upperBoundValue);
        }
        
    	BlockRulesRow(BlockBy blockBy) {
            this.blockBy = blockBy;
            this.field = blockBy.getField();
            this.operator = blockBy.getOperator();
            this.useConstant = blockBy.useConstant();
            if (this.useConstant) {
                this.source = blockBy.getConstant();
            } else {
                this.source = blockBy.getSource();
            }
            this.lowerBoundType = blockBy.getLowerBoundType();
            this.lowerBoundValue = blockBy.getLowerBoundValue();
            this.upperBoundType = blockBy.getUpperBoundType();
            this.upperBoundValue = blockBy.getUpperBoundValue();
        }
        
        public void setBlockBy(BlockBy blockBy) {
            this.blockBy = blockBy;
        }
        
        public BlockBy getBlockBy() {
            return this.blockBy;
        }
        
        public void setSource(String source) {
            this.source = source;
        }
        
        public String getSource() {
            return source;
        }

        public void setField(String field) {
            this.field = field;
        }

        public String getField() {
            return field;
        }
        
        public void setOperator(String operator) {
            this.operator = operator;
        }
        
        public String getOperator() {
            return operator;
        }
         
        public void setUseConstant(boolean flag) {
            useConstant = flag;
        }
        
        public boolean getUseConstant() {
            return useConstant;
        }
  }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
    }
    
    // TreeSelectionListener
    public void valueChanged(TreeSelectionEvent e) {
        EntityNode selectedNode = (EntityNode) e.getPath().getLastPathComponent();

        if (selectedNode.isField()) {
            TreeNode[] nodes = selectedNode.getPath();
            String fieldNamePath = "";
            for (int i=0; i < nodes.length; i++) {
                EntityNode node = (EntityNode) nodes[i];
                String nodeName = node.getName();
                if (node.isRoot()) {
                } else if (node.isPrimary()) {
                    fieldNamePath = nodeName;
                } else if (node.isSub()) {
                    fieldNamePath += "." + nodeName + "[*]";
                } else { // isField
                    fieldNamePath += "." + nodeName;
                }
            }
            //txtTargetFieldName.setText(fieldNamePath);
            //btnOK.setEnabled(mTblBlockRules.getRowCount() > 0);
            btnAddBlockRule.setEnabled(true);
        } else {
            //txtTargetFieldName.setText("");
            //btnOK.setEnabled(false);
            btnAddBlockRule.setEnabled(false);            
        }
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnAddBlockRule;
    private javax.swing.JButton btnCancel;
    private javax.swing.JButton btnEditBlockRule;
    private javax.swing.JButton btnOK;
    private javax.swing.JButton btnRemoveBlockRule;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabelBlockingRuleName;
    private javax.swing.JLabel jLabelHint;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPaneBlockRules;
    private javax.swing.JTextField jTextFieldBlockingRuleName;
    private javax.swing.JTextField jTextFieldHint;
    private javax.swing.JTextField jTextFieldQueryBuilderName;
    private javax.swing.JLabel lblBlockBy;
    // End of variables declaration//GEN-END:variables
    
}
