/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
 *
 * Copyright 2003-2007 Sun Microsystems, Inc. All Rights Reserved.
 *
 * The contents of this file are subject to the terms of the Common 
 * Development and Distribution License ("CDDL")(the "License"). You 
 * may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the License at
 * https://open-dm-mi.dev.java.net/cddl.html
 * or open-dm-mi/bootstrap/legal/license.txt. See the License for the 
 * specific language governing permissions and limitations under the  
 * License.  
 *
 * When distributing the Covered Code, include this CDDL Header Notice 
 * in each file and include the License file at
 * open-dm-mi/bootstrap/legal/license.txt.
 * If applicable, add the following below this CDDL Header, with the 
 * fields enclosed by brackets [] replaced by your own identifying 
 * information: "Portions Copyrighted [year] [name of copyright owner]"
 */
package com.sun.mdm.index.potdup;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.logging.Logger;
import java.util.logging.Level;
import javax.naming.Context;
import javax.naming.InitialContext;
import com.sun.mdm.index.ejb.master.MasterController;
import com.sun.mdm.index.ejb.page.PageData;
import com.sun.mdm.index.idgen.CUIDManager;
import com.sun.mdm.index.master.search.potdup.PotentialDuplicateIterator;
import com.sun.mdm.index.master.search.potdup.PotentialDuplicateSearchObject;
import com.sun.mdm.index.master.search.potdup.PotentialDuplicateSummary;
import com.sun.mdm.index.objects.PotentialDuplicate;
import com.sun.mdm.index.objects.exception.ObjectException;
import com.sun.mdm.index.ops.DBAdapter;
import com.sun.mdm.index.ops.exception.OPSException;
import com.sun.mdm.index.page.PageAdapter;
import com.sun.mdm.index.page.PotentialDuplicatePageAdapter;
import com.sun.mdm.index.util.Localizer;
import com.sun.mdm.index.util.Constants;
import com.sun.mdm.index.util.JNDINames;


import com.sun.mdm.index.master.UserException;

/**
 * Data access class for potential duplicates
 * @author Dan Cidon
 */
public class PotentialDuplicateManager {

	private static String mNumberConversion = null;
        
    /**  retrieval for potential duplicates without LIDs */
    private static final String NO_LID_BASE_SELECT_CLAUSE = 
       "SELECT a.potentialduplicateid, a.weight, a.description, a.status, " 
       + "a.resolveduser, a.resolveddate, a.resolvedcomment, a.euid2, a.euid1, "
       + "b.systemuser, b.timestamp, b.systemcode "
       + "FROM sbyn_potentialduplicates a, sbyn_transaction b "
       + "WHERE a.transactionnumber = b.transactionnumber ";
    
    /** SQL string to retrieve potential duplicate
     */    
    private static  String BASE_SELECT_CLAUSE = null;
            
    /** Same as base, plus filter on EUIDs
     */    
    private static  String EUID_SELECT_CLAUSE = null;
    /** Same as base, plus retrieval of all potential duplicates and not just
     *  the ones generated by an updated.
     */    
    private static  String ALL_POT_DUP_SELECT_CLAUSE = null;

    
         // convert a string to a number
    
    /** Handle to Master Controller
     */    
    private final MasterController mc;
    
    private transient Logger mLogger = Logger.getLogger(this.getClass().getName());
    private transient Localizer mLocalizer = Localizer.get();
    
    /** Creates a new instance of PotDupManager
     *
     * @param mc Handle to master controller
     */
    public PotentialDuplicateManager(MasterController mc) throws OPSException {
        this.mc = mc;
        if (mNumberConversion == null) {
            mNumberConversion = 
                DBAdapter.getDBAdapterInstance().getVarcharToNumberConversion("a.WEIGHT");
            BASE_SELECT_CLAUSE = 
                "select distinct "
                + "a.POTENTIALDUPLICATEID, "
                + "a.WEIGHT, "
                + "a.DESCRIPTION, "
                + "a.STATUS, "
                + "a.RESOLVEDUSER, "
                + "a.RESOLVEDDATE, "
                + "a.RESOLVEDCOMMENT, "
                + "a.EUID2, "
                + "a.EUID1, "
                + "b.SYSTEMUSER, "
                + "b.TIMESTAMP, "
                + "b.SYSTEMCODE, "
                + mNumberConversion 
                + " from SBYN_POTENTIALDUPLICATES a, SBYN_TRANSACTION b, SBYN_ENTERPRISE e "
                + "where a.TRANSACTIONNUMBER = b.TRANSACTIONNUMBER ";
            EUID_SELECT_CLAUSE = BASE_SELECT_CLAUSE 
            + "and (a.EUID1=? or a.EUID1=? or a.EUID2=? or a.EUID2=?) ";
            ALL_POT_DUP_SELECT_CLAUSE = BASE_SELECT_CLAUSE 
            + "and (e.euid = a.euid1 or e.euid = a.euid2) " ;
        }
        
    }


    /** Add potential duplicates to the database. The euid1 field of all
     * potential duplicates must match the euid parameter.
     *
     * @param transactionId The feature to be added to the PotentialDuplicates
     *      attribute
     * @param con The feature to be added to the PotentialDuplicates attribute
     * @param euid The feature to be added to the PotentialDuplicates attribute
     * @param pdArray The feature to be added to the PotentialDuplicates
     *      attribute
     * @exception PotentialDuplicateException An error has occurred.
     */
    public void addPotentialDuplicates(Connection con, String euid,
            PotentialDuplicate[] pdArray, String transactionId)
        throws PotentialDuplicateException {
        try {
            //Filter out all duplicates that are already in the db
            Iterator potDupIterator = filterExistingDuplicates(
                    con, euid, pdArray).iterator();
            String sql = "INSERT into SBYN_POTENTIALDUPLICATES "
                    + "(POTENTIALDUPLICATEID,WEIGHT,DESCRIPTION,STATUS,EUID1,"
                    + "EUID2,TRANSACTIONNUMBER) VALUES (?,?,?,?,?,?,?)";
            PreparedStatement ps = con.prepareStatement(sql);
            while (potDupIterator.hasNext()) {
                PotentialDuplicate pd = 
                    (PotentialDuplicate) potDupIterator.next();
                if (!euid.equals(pd.getEUID1())) {
                    throw new PotentialDuplicateException("Invalid EUID1 for " 
                            + "potential duplicate.");
                }
                String potDupId = CUIDManager.getNextUID( con, "POTENTIALDUPLICATE" );
                ps.setString(1, potDupId);
                ps.setString(2, "" + pd.getProbability());
                ps.setString(3, pd.getDescription());
                ps.setString(4, "U");
                ps.setString(5, pd.getEUID1());
                ps.setString(6, pd.getEUID2());
                ps.setString(7, transactionId);
                ps.executeUpdate();
            }
            ps.close();
        } catch (Exception e) {
            throw new PotentialDuplicateException(e);
        }
    }


    /** Delete all duplicates for given euid except those marked as auto resolve.
     *
     * @param euid EUID parameter
     * @param con Connection handle
     * @throws PotentialDuplicateException An error has occurred.
     */
    public void deletePotentialDuplicates(Connection con, String euid)
        throws PotentialDuplicateException {
        try {
            String sql = "DELETE FROM SBYN_POTENTIALDUPLICATES " 
                    + "WHERE (euid1 = ? OR euid2 = ?) AND status!='A'";
            PreparedStatement ps = con.prepareStatement(sql);
            ps.setString(1, euid);
            ps.setString(2, euid);
            ps.executeUpdate();
            ps.close();
        } catch (SQLException e) {
            throw new PotentialDuplicateException(e);
        }
    }


    /** Search for potential duplicates
     * @param obj Search object.
     * @param con Connection handle.
     * @exception PotentialDuplicateException An error has occurred.
     * @return Iterator of search results.
     */
    public PotentialDuplicateIterator lookupPotentialDuplicates(
            Connection con, PotentialDuplicateSearchObject obj)
        throws PotentialDuplicateException {
            
        PreparedStatement ps = null;
        ArrayList parameters = new ArrayList();
        StringBuffer sb = new StringBuffer();
        //  Keeps track of whether an LID was given as a search parameter
        boolean noLidFlag = false;

        if (obj.getLID() != null) {
            sb = new StringBuffer(ALL_POT_DUP_SELECT_CLAUSE);
            noLidFlag = false;
        } else {
            sb = new StringBuffer(NO_LID_BASE_SELECT_CLAUSE);
            noLidFlag = true;
        }

        if (mLogger.isLoggable(Level.FINE)) {
            mLogger.fine("Potential Duplicate Search Object is: " + obj);
        }
        try {
            if (obj.getEUIDs() != null) {
                StringBuffer euidList = new StringBuffer();
                String[] euids = obj.getEUIDs();
                for (int i = 0; i < euids.length; i++) {
                    if (i != 0) {
                        euidList.append(",");
                    }
                    euidList.append('\'').append(euids[i]).append('\'');
                }
                String euidListString = euidList.toString();
                sb.append(" and (a.EUID1 in (").append(euidListString);
                sb.append(") or a.EUID2 in (").append(euidListString);
                sb.append("))");
            }
            if (obj.getSystemCode() != null) {
                if (noLidFlag == false) {
                    sb.append(" and e.SYSTEMCODE=?");
                } else {
                    sb.append(" and b.SYSTEMCODE=?");
                }
                parameters.add(obj.getSystemCode());
            }
            if (obj.getLID() != null) {
                sb.append(" and e.lid=?");
                parameters.add(obj.getLID());
            }
            if (obj.getStatus() != null) {
                sb.append(" and a.STATUS=?");
                parameters.add(obj.getStatus());
            }
            if (obj.getType() != null) {
                sb.append(" and a.TYPE=?");
                parameters.add(obj.getType());
            }
            if (obj.getCreateUser() != null) {
                sb.append(" and b.SYSTEMUSER=?");
                parameters.add(obj.getCreateUser());
            }
            if (obj.getCreateStartDate() != null) {
                sb.append(" and b.TIMESTAMP>=?");
                parameters.add(obj.getCreateStartDate());
            }
            if (obj.getCreateEndDate() != null) {
                sb.append(" and b.TIMESTAMP<=?");
                parameters.add(obj.getCreateEndDate());
            }
            if (obj.getResolvedUser() != null) {
                sb.append(" and RESOLVEDUSER=?");
                parameters.add(obj.getResolvedUser());
            }
            if (obj.getResolvedStartDate() != null) {
                sb.append(" and RESOLVEDDATE>=?");
                parameters.add(obj.getResolvedStartDate());
            }
            if (obj.getResolvedEndDate() != null) {
                sb.append(" and RESOLVEDDATE<=?");
                parameters.add(obj.getResolvedEndDate());
            }
            
            sb.append(" order by " 
                      + mNumberConversion
                      + " desc, a.EUID1 asc");
            String sqlString = sb.toString();
            if (mLogger.isLoggable(Level.FINE)) {
                mLogger.fine("PotentialDuplicateManager: Executing SQL String: " + sqlString);
            }
            ps = con.prepareStatement(sqlString);
            for (int i = 0; i < parameters.size(); i++) {
                ps.setObject(i + 1, parameters.get(i));
            }
        } catch (SQLException e) {
            throw new PotentialDuplicateException(e);
 
        }
        return lookupPotentialDuplicates(con, ps, obj);
    }

    /** Count the potential duplicates records matching the search criteria.
     * This does not handle EUID nor Source/LID search criteria.
     * @param obj Search object.
     * @param con Connection handle.
     * @exception PotentialDuplicateException An error has occured.
     * @return Count of the potential duplicates matching the search criteria.
     */
    public int countPotentialDuplicates(
            Connection con, PotentialDuplicateSearchObject obj)
        throws PotentialDuplicateException {
            
        String countSelectClause = 
                "select count(*) "
                + " from SBYN_POTENTIALDUPLICATES a, SBYN_TRANSACTION b"
                + " where a.TRANSACTIONNUMBER = b.TRANSACTIONNUMBER ";
                
        PreparedStatement ps = null;
        ResultSet rs = null;
        ArrayList parameters = new ArrayList();
        StringBuffer sb = new StringBuffer(countSelectClause);

        try {
            if (obj.getStatus() != null) {
                sb.append(" and a.STATUS=?");
                parameters.add(obj.getStatus());
            }
            if (obj.getType() != null) {
                sb.append(" and a.TYPE=?");
                parameters.add(obj.getType());
            }
            if (obj.getCreateUser() != null) {
                sb.append(" and b.SYSTEMUSER=?");
                parameters.add(obj.getCreateUser());
            }
            if (obj.getCreateStartDate() != null) {
                sb.append(" and b.TIMESTAMP>=?");
                parameters.add(obj.getCreateStartDate());
            }
            if (obj.getCreateEndDate() != null) {
                sb.append(" and b.TIMESTAMP<=?");
                parameters.add(obj.getCreateEndDate());
            }
            if (obj.getResolvedUser() != null) {
                sb.append(" and RESOLVEDUSER=?");
                parameters.add(obj.getResolvedUser());
            }
            if (obj.getResolvedStartDate() != null) {
                sb.append(" and RESOLVEDDATE>=?");
                parameters.add(obj.getResolvedStartDate());
            }
            if (obj.getResolvedEndDate() != null) {
                sb.append(" and RESOLVEDDATE<=?");
                parameters.add(obj.getResolvedEndDate());
            }
            String sqlString = sb.toString();
            ps = con.prepareStatement(sqlString);
            for (int i = 0; i < parameters.size(); i++) {
                ps.setObject(i + 1, parameters.get(i));
            }
            int count = 0;
            rs = ps.executeQuery();
            if (rs.next()) {
                count = rs.getInt(1);
            } 
            return count;
        } catch (SQLException e) {
            throw new PotentialDuplicateException(e);
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (ps != null) {
                    ps.close();
                }
            } catch (Exception e) {
                mLogger.info("Could not close the result set nor the prepared statement: " + 
                              e.getMessage());
                throw new PotentialDuplicateException(e);
            } 
        }
    }


    /** Set status of potential duplicate record to either (r)esolve or
     * (a)utoresolve.
     *
     * @param potDupId Id of potential duplicate
     * @param autoResolve Set true if want to auto resolve
     * @param con Connection handle
     * @exception PotentialDuplicateException An error has occurred.
     */
    public void resolvePotentialDuplicate(Connection con, String potDupId,
            boolean autoResolve)
        throws PotentialDuplicateException, UserException {
        try {
            char statusChar = autoResolve ? 'A' : 'R';
            String sql = "UPDATE SBYN_POTENTIALDUPLICATES set status='" 
            + statusChar + "' where POTENTIALDUPLICATEID = ?";
            PreparedStatement ps = con.prepareStatement(sql);
            ps.setString(1, potDupId);
            ps.executeUpdate();
            ps.close();
        } catch (SQLException e) {
            throw new PotentialDuplicateException(e);
        }
    }


    /** Set status of potential duplicate record to either (u)resolved
     *
     * @param potDupId Id of potential duplicate.
     * @param con Connection handle.
     * @exception PotentialDuplicateException An error has occurred.
     */
    public void unresolvePotentialDuplicate(Connection con, String potDupId)
        throws PotentialDuplicateException, UserException {
        try {
            String sql = "UPDATE SBYN_POTENTIALDUPLICATES " 
                    + "set status='U' where POTENTIALDUPLICATEID = ?";
            PreparedStatement ps = con.prepareStatement(sql);
            ps.setString(1, potDupId);
            ps.executeUpdate();
            ps.close();
        } catch (SQLException e) {
            throw new PotentialDuplicateException(e);
        }
    }


    /** Given an array of potential duplicates, filter out those duplicates that
     * already exist in the database.
     *
     * @param con Connection handle.
     * @param euid EUID to search for existing duplicates.
     * @param pd Potential duplicates to be filtered.
     * @exception PotentialDuplicateException An error has occurred.
     * @exception ObjectException An error has occurred.
     * @return List of filtered potential duplicates.
     */
    private ArrayList filterExistingDuplicates(Connection con,
            String euid, PotentialDuplicate[] pd)
        throws PotentialDuplicateException, ObjectException {
        HashMap existingDups = findAllDuplicates(con, euid);
        ArrayList list = new ArrayList();
        for (int i = 0; i < pd.length; i++) {
            String euid2 = pd[i].getEUID2();
            if (existingDups.get(euid2) == null) {
                list.add(pd[i]);
            }
        }
        return list;
    }


    /** Return an arraylist of euid's (String) for all potential duplicates that
     * exist for the given euid
     *
     * @param con Connection handle.
     * @param euid EUID parameter.
     * @exception PotentialDuplicateException An error has occurred.
     * @return Map of EUID's that were found
     */
    private HashMap findAllDuplicates(Connection con, String euid)
        throws PotentialDuplicateException {
        try {
            String sql = "SELECT euid1, euid2 FROM SBYN_POTENTIALDUPLICATES " 
                    + "WHERE euid1 = ? OR euid2 = ?";
            PreparedStatement ps = con.prepareStatement(sql);
            ps.setString(1, euid);
            ps.setString(2, euid);
            ResultSet rs = ps.executeQuery();
            HashMap retMap = new HashMap();
            while (rs.next()) {
                String euid1 = rs.getString(1);
                String euid2 = rs.getString(2);
                if (euid1.equals(euid)) {
                    retMap.put(euid2, euid2);
                } else {
                    retMap.put(euid1, euid1);
                }
            }
            rs.close();
            ps.close();
            return retMap;
        } catch (SQLException e) {
            throw new PotentialDuplicateException(e);
        }
    }

    /** Lookup potential duplicates
     * @param con Connection handle.
     * @param ps Prepared statement to execut.
     * @param searchObj Search criteria.
     * @throws PotentialDuplicateException An error has occurred.
     * @return Iterator of search results.
     */    
    private PotentialDuplicateIterator lookupPotentialDuplicates(
            Connection con, PreparedStatement ps, 
            PotentialDuplicateSearchObject searchObj)
        throws PotentialDuplicateException {
        try {
            ResultSet rs = ps.executeQuery();
            ArrayList duplicates = new ArrayList();
            int count = 0;
            int maxElements = searchObj.getMaxElements();
            while (rs.next()) {
                if (count >= maxElements) {
                    break;
                }
                String id = rs.getString(1);
                String weight = rs.getString(2);
                String description = rs.getString(3);
                String status = rs.getString(4);
                String resolvedUser = rs.getString(5);
                Date resolvedDate = rs.getTimestamp(6);
                String resolvedComment = rs.getString(7);
                String euid2 = rs.getString(8);
                String euid1 = rs.getString(9);
                String createUser = rs.getString(10);
                Date createDate = rs.getTimestamp(11);
                String systemCode = rs.getString(12);
                PotentialDuplicateSummary dupSum = new PotentialDuplicateSummary
                        (mc, searchObj, id, euid1, euid2, status, description,
                        Float.parseFloat(weight), systemCode, createUser, 
                        createDate, resolvedUser, resolvedDate, 
                        resolvedComment);
                duplicates.add(dupSum);
                count++;
            }
            rs.close();
            ps.close();

            //If result set is small enough, send all results to client without
            //going through PageData session bean
            PotentialDuplicateIterator retIterator = null;
            int pageSize = searchObj.getPageSize();
            PageAdapter adapter = 
                new PotentialDuplicatePageAdapter(duplicates, searchObj);
            
            if (count < 2 * pageSize) {
                ArrayList summaryRecordList = new ArrayList();
                while (adapter.hasNext()) {
                    summaryRecordList.add(adapter.next()); 
                }
                retIterator = new PotentialDuplicateIterator(summaryRecordList);
                
            } else {
                Context jndiContext = new InitialContext();
                PageData pd = (PageData) jndiContext.lookup(JNDINames.EJB_REF_PAGEDATA);
                pd.setPageAdapter( adapter );
                retIterator = new PotentialDuplicateIterator( pd, pageSize, count );
            }
                 
            return retIterator;
        } catch (Exception e) {
            throw new PotentialDuplicateException(e);
        }
    }

}
